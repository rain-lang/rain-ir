/*!
Bitvector negation
*/

use super::*;

/// The negation operator
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct Neg;

/// Perform bitvector negation, discarding bits of order greater than `len`
#[inline(always)]
pub fn masked_neg(len: u32, b: u128) -> u128 {
    mask(len, b.wrapping_neg())
}

debug_from_display!(Neg);
quick_pretty!(Neg, "#neg");
trivial_substitute!(Neg);
enum_convert! {
    impl InjectionRef<ValueEnum> for Neg {}
    impl TryFrom<NormalValue> for Neg { as ValueEnum, }
    impl TryFromRef<NormalValue> for Neg { as ValueEnum, }
}

impl From<Neg> for NormalValue {
    fn from(a: Neg) -> NormalValue {
        a.into_norm()
    }
}

impl Regional for Neg {}

impl Apply for Neg {
    fn apply_in<'a>(
        &self,
        args: &'a [ValId],
        ctx: &mut Option<EvalCtx>,
    ) -> Result<Application<'a>, Error> {
        if args.len() <= 1 {
            self.ty().apply_ty_in(args, ctx).map(Application::Symbolic)
        } else {
            let operand = args[1].as_enum();
            let operand_ty = operand.ty();
            if operand_ty != args[0] || operand_ty.ty() != *BITS_KIND {
                return Err(Error::TypeMismatch);
            }
            match operand {
                ValueEnum::Bits(b) if b.ty() == args[0] => {
                    let result = Bits {
                        ty: b.ty.clone(),
                        data: masked_neg(b.len, b.data),
                        len: b.len,
                    };
                    result.apply_in(&args[2..], ctx)
                }
                _ => operand_ty
                    .apply_ty_in(&args[2..], ctx)
                    .map(Application::Symbolic),
            }
        }
    }
}

impl Typed for Neg {
    #[inline]
    fn ty(&self) -> TypeRef {
        BITS_UNARY.borrow_ty()
    }
    #[inline]
    fn is_ty(&self) -> bool {
        false
    }
    #[inline]
    fn is_kind(&self) -> bool {
        false
    }
}

impl Type for Neg {
    #[inline]
    fn is_affine(&self) -> bool {
        false
    }
    #[inline]
    fn is_relevant(&self) -> bool {
        false
    }
}

impl Value for Neg {
    fn no_deps(&self) -> usize {
        0
    }
    fn get_dep(&self, ix: usize) -> &ValId {
        panic!(
            "Add operation {} has no dependencies (tried to get dep #{})",
            self, ix
        )
    }
    #[inline]
    fn into_enum(self) -> ValueEnum {
        ValueEnum::Neg(self)
    }
    #[inline]
    fn into_norm(self) -> NormalValue {
        NormalValue::assert_normal(ValueEnum::Neg(self))
    }
}

impl ValueData for Neg {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn constant_bitvector_negation_works() {
        let test_cases: &[(u32, u128, u128)] = &[(4, 2, 14), (4, 0, 0), (10, 1, 1023)];
        for (len, data, result) in test_cases.iter() {
            let bitwidth = BitsTy(*len).into_var();
            let op_data = bitwidth.data(*data).expect("data is valid");
            let data_arr = [bitwidth.into_val(), op_data.into_val()];
            let mut ctx = None;
            match Neg.apply_in(&data_arr[..], &mut ctx).unwrap() {
                Application::Success(&[], v) => match v.as_enum() {
                    ValueEnum::Bits(b) => {
                        assert_eq!(b.len, *len);
                        assert_eq!(b.data, *result);
                        assert_eq!(b.data, mask(*len, data.wrapping_neg()));
                        assert_eq!(b.data, masked_neg(*len, *data));
                    }
                    _ => panic!("Result should be a bitvector constant (ValueEnum::Bits)"),
                },
                _ => panic!("Application should not be symbolic"),
            };
            assert_eq!(
                ctx, None,
                "No evaluation context should be generated by direct addition of constants"
            );
        }
    }
}
